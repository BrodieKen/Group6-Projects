#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/* what it does
- calculates optimal path 100% done
- saves this path in PathTaken, has random 9s where values are eliminated
*/
/* Todo
- figure out how to ignore said 9s <DONE March 23 - Khail>
- detect whether to drive straight or line track <DONE March 23 - Khail>
		- checking next and current paths
- line track <DONE March 23 - Khail, needs irl test>
- stop line tracking when turned 90 degrees <March 23 - Khail, needs to be tweaked to be more precise, relies on orientation variable right now>
- keep track of current row and col to know when to STOP
- expand maze to biiiiiig size <DONE March 23 - Khail>

	Todo as of March 23rd:
- change targetColor to yellow at appropriate spot
- modify lineTracking stop condition
- possibly add calibration before lineTracking
- get accurate encoder value for gridLength
- display finish message
- tweak arrayLength and loop iterations... maybe find a way to store the length of the optimal path?
*/

/*
Additions/Changes made march 28
- added input from the robot screen for start and target cell
- added a new part of the matrix class for target colour
*/
const int screenHeight = 127;
const int screenWidth  = 177;
const int numOfRows = 7;
const int numOfCols = 9;

int startRow = 3;
int startCol = 1;
int targetRow = 4;
int targetCol = 8;
int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
int robRow = startRow;
int robCol = startCol;
int orientation = 0;
int angle = 0;
int gridLength = 800;
int motorSpeed = 25;
const int arrayLength = 100;
int red;
int blue;
int green;
int targetColorRed = 7;
int targetColorGreen = 9;

typedef struct{
	int nWall;  // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;
	int color;

}cell;

cell maze[numOfRows][numOfCols];

int pathIndex = 0;
int pathTaken[arrayLength];
int directionMarix[4][4];


void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void MazeSim();
void refreshScreen();
void solveMazeRWF();
void optimizePath();
void populateDirectionMatrix();
void goFwdIRL();
void turnRightIRL();
void checkDirection();
void lineTrack(int allignmentVal, int targetAngle);
void inputStartAndEnd();




task main(){
	//initialize maze and solve virtually
	for (int i = 0; i<arrayLength;i++){
		pathTaken[i] = 9;
	}
	//inputStartAndEnd();	//Comment out for manual input from the code for start and end positions
	buildOuterBorders();
	MazeSim();
	refreshScreen();
	while(robRow!= targetRow || robCol != targetCol){
		solveMazeRWF();
		refreshScreen();
		sleep(10);
	}
	refreshScreen();
	optimizePath();
	sleep(1000);


	//follow optimized path
	if (pathTaken[0]!= 0){
		for (int j=0; j < directionMarix[0][pathTaken[0]]; j++){
			turnRightIRL();
			orientation++;
			if (orientation ==4) {
				orientation = 0;
			}
		}
	}


	int i = 0;
	while(robRow != targetRow && robCol != targetCol) {
			if (orientation != pathTaken[i]){
				for (int j=0; j < directionMarix[orientation][pathTaken[i]]; j++){
					turnRightIRL();
					orientation++;
					if (orientation ==4) {
						orientation = 0;
					}
				}
			}
			else if (orientation == pathTaken[i]){
				goFwdIRL();
				switch(orientation){
					case 0: robRow++;break;
					case 1: robCol++;break;
					case 2: robRow--;break;
					case 3: robCol--;break;
					default: break;
				}
				i++;
			}
	}
}




/*----Motion Functions----*/
void goFwdIRL(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,gridLength, motorSpeed);
	setMotorTarget(rightMotor,gridLength, motorSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void turnRightIRL(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,360 ,motorSpeed);
	setMotorTarget(rightMotor,-360,motorSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void populateDirectionMatrix(){
	/*
		0	1	2	3
		3	0	1	2
		2	3	0	1
		1	2	3	0
	*/
	//[current] [desired]
	directionMarix[0][0] = 0;
	directionMarix[0][1] = 1;
	directionMarix[0][2] = 2;
	directionMarix[0][3] = 3;
	directionMarix[1][0] = 3;
	directionMarix[1][1] = 0;
	directionMarix[1][2] = 1;
	directionMarix[1][3] = 2;
	directionMarix[2][0] = 2;
	directionMarix[2][1] = 3;
	directionMarix[2][2] = 0;
	directionMarix[2][3] = 1;
	directionMarix[3][0] = 1;
	directionMarix[3][1] = 2;
	directionMarix[3][2] = 3;
	directionMarix[3][3] = 0;
}

/*-------Virtual Optimization of path functions---*/

//solve and optimization functions//
void optimizePath(){
	//this will modify the path taken to be the fastest path
	for (int optimizeIterations = 0; optimizeIterations<arrayLength;optimizeIterations++) {
		for(int i = 0; i <= pathIndex; i++){
			switch(pathTaken[i]){
				case 0: if(pathTaken[i+1] == 2){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
				case 1:	if(pathTaken[i+1] == 3){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
				case 2:	if(pathTaken[i+1] == 0){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
				case 3:	if(pathTaken[i+1] == 1){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
				default: break;
			}
		}
		int newPathTaken[arrayLength];
		for (int j = 0; j<arrayLength;j++){
			newPathTaken[j] = 9;
		}
		int newStepCount = 0;
		for(int k = 0; k <= pathIndex; k++){
			if(pathTaken[k] != 9) {
				newPathTaken[newStepCount] = pathTaken[k];
				newStepCount++;
			}
		}
		for (int l = 0; l<arrayLength;l++){
			pathTaken[l] = newPathTaken[l];
		}
	}
}

void solveMazeRWF(){
	// solve the maze using RWF method. for LWF swap left and right turns
	turnRight();
	bool moved = false;
	while(moved == false){
		switch (robHeading){
			case 0: if(maze[robRow][robCol].nWall == 0){goFwd();moved = true; }else {turnLeft();} break;
			case 1: if(maze[robRow][robCol].eWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			case 2:	if(maze[robRow][robCol].sWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			case 3:	if(maze[robRow][robCol].wWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			default: break;

		}
	}
}

//mazze building functions//
void inputStartAndEnd(){
	int num = 0;
	int settings = 0;
	int buttonState = 0;
	while(settings < 5){
		if(getButtonPress(buttonUp) == true){
			num++;
		}
		else if(getButtonPress(buttonDown) == true){
			num--;
		}
		switch(settings){
			case 0:	//robot start row
				if(num>7){num = 0;}
				else if(num<0){num = 7;}
				startRow = num;
				break;
			case 1:	//robot start col
				if(num>9){num = 0;}
				else if(num<0){num = 9;}
				startCol = num;
				break;
			case 2:	//robot target row
				if(num>7){num = 0;}
				else if(num<0){num = 7;}
				targetRow = num;
				break;
			case 3:	//robot target col
				if(num>7){num = 0;}
				else if(num<0){num = 7;}
				targetCol = num;
				break;
			case 4:	//confirm ready to begin
				waitForButtonPress();
        settings++;
        break;//when enter button released, switch to next setting
			default: break;
		}
		displayTextLine(1, "Robot Start Row: %d",startRow);
		displayTextLine(3, "Robot Start Column: %d",startCol);
		displayTextLine(5, "Robot Target Row: %d",targetRow);
		displayTextLine(7, "Robot Target Column: %d",targetCol);

		if (getButtonPress(buttonEnter)== 1 && buttonState == 0){
			settings++;	//when enter button released, switch to next setting
			buttonState = 1;
		}
		else if(getButtonPress(buttonEnter)== 0 && buttonState == 1){
			buttonState = 0;
		}
		wait1Msec(100);
	}
}


void MazeSim(){

	//column 0
	maze[6][0].sWall = maze[5][0].nWall = 1;
	maze[5][0].sWall = maze[4][0].nWall = 1;
	maze[4][0].sWall = maze[3][0].nWall = 1;
	maze[3][0].sWall = maze[2][0].nWall = 1;
	maze[2][0].sWall = maze[1][0].nWall = 1;
	maze[1][0].sWall = maze[0][0].nWall = 1;

	maze[0][0].eWall = maze[0][1].wWall = 1;
	maze[3][0].eWall = maze[3][1].wWall = 1;
	maze[5][0].eWall = maze[5][1].wWall = 1;

	//column 1
	maze[5][1].sWall = maze[4][1].nWall = 1;
	maze[4][1].sWall = maze[3][1].nWall = 1;
	maze[2][1].sWall = maze[1][1].nWall = 1;
	maze[1][1].sWall = maze[0][1].nWall = 1;

	maze[6][1].eWall = maze[6][2].wWall = 1;
	maze[2][1].eWall = maze[2][2].wWall = 1;

	//column 2
	maze[6][2].eWall = maze[6][3].wWall = 1;
	maze[5][2].eWall = maze[5][3].wWall = 1;
	maze[2][2].eWall = maze[2][3].wWall = 1;

	//column 3
	maze[6][3].sWall = maze[5][3].nWall = 1;
	maze[5][3].sWall = maze[4][3].nWall = 1;
	maze[4][3].sWall = maze[3][3].nWall = 1;
	maze[2][3].sWall = maze[1][3].nWall = 1;
	maze[1][3].sWall = maze[0][3].nWall = 1;

	maze[6][3].eWall = maze[6][4].wWall = 1;
	maze[5][3].eWall = maze[5][4].wWall = 1;
	maze[3][3].eWall = maze[3][4].wWall = 1;

	//column 4
	maze[6][4].sWall = maze[5][4].nWall = 1;
	maze[3][4].sWall = maze[2][4].nWall = 1;
	maze[2][4].sWall = maze[1][4].nWall = 1;
	maze[1][4].sWall = maze[0][4].nWall = 1;

	maze[6][4].eWall = maze[6][5].wWall = 1;
	maze[3][4].eWall = maze[3][5].wWall = 1;
	maze[0][4].eWall = maze[0][5].wWall = 1;

	//column 5
	maze[5][5].sWall = maze[4][5].nWall = 1;
	maze[4][5].sWall = maze[3][5].nWall = 1;
	maze[2][5].sWall = maze[1][5].nWall = 1;
	maze[1][5].sWall = maze[0][5].nWall = 1;

	maze[6][5].eWall = maze[6][6].wWall = 1;
	maze[5][5].eWall = maze[5][6].wWall = 1;
	maze[4][5].eWall = maze[4][6].wWall = 1;
	maze[3][5].eWall = maze[3][6].wWall = 1;
	maze[0][5].eWall = maze[0][6].wWall = 1;

	//column 6
	maze[2][6].sWall = maze[1][6].nWall = 1;
	maze[1][6].sWall = maze[0][6].nWall = 1;

	maze[6][6].eWall = maze[6][7].wWall = 1;
	maze[5][6].eWall = maze[5][7].wWall = 1;
	maze[4][6].eWall = maze[4][7].wWall = 1;
	maze[3][6].eWall = maze[3][7].wWall = 1;
	maze[2][6].eWall = maze[2][7].wWall = 1;

	//column 7
	maze[6][7].eWall = maze[6][8].wWall = 1;
	maze[5][7].eWall = maze[5][8].wWall = 1;
	maze[3][7].eWall = maze[3][8].wWall = 1;
	maze[2][7].eWall = maze[2][8].wWall = 1;
	maze[0][7].eWall = maze[0][8].wWall = 1;

	//column 8
	maze[6][8].sWall = maze[5][8].nWall = 1;
	maze[5][8].sWall = maze[4][8].nWall = 1;
	maze[4][8].sWall = maze[3][8].nWall = 1;
	maze[3][8].sWall = maze[2][8].nWall = 1;
	maze[2][8].sWall = maze[1][8].nWall = 1;

	for(int i = 0; i <numOfCols;i++){
		for(int j =0; j<numOfRows;j++){
			if(i>4){
				maze[j][i].color = 40; //yellow
			}
			else{
				maze[j][i].color = 5; //black
			}
		}
	}
}

void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		maze[0][col].sWall = 1;
		maze[numOfRows-1][col].nWall = 1;
	}

	for(int row=0; row<numOfRows; row++){
		maze[row][0].wWall = 1;
		maze[row][numOfCols-1].eWall = 1;
	}
}

void refreshScreen(){
	eraseDisplay();
	gridDraw();
	drawBot();
}


//virtual Motion functions//
void goFwd(){
	//wait1Msec(1000);  // waste some time to simulate motion
	if (robHeading==0)	{   // Going Fwd North
		robRow++;
	}
	else if (robHeading==1)	{   // Going Fwd East
		robCol++;
	}
	else if (robHeading==2)	{   // Going Fwd South
		robRow--;
	}
	else if (robHeading==3)	{   // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	pathTaken[pathIndex] = robHeading;
	pathIndex++;

}

void turnRight(){
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}

void turnLeft(){
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}

//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd  =0;
	int YEnd  =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(maze[i][j].nWall==1){
					XStart= j   *screenWidth/numOfCols;
					YStart=(i+1)*screenHeight/numOfRows;
					XEnd  =(j+1)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].eWall==1){
					XStart=(j+1)*screenWidth/numOfCols;
					YStart=(i)*screenHeight/numOfRows;
					XEnd  =(j+1)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].wWall==1){
					XStart= j   *screenWidth/numOfCols;
					YStart=(i)*screenHeight/numOfRows;
					XEnd  =(j)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(maze[i][j].sWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}

//=====================================================================
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;

	if(robCol==0){
			RobotXpixelPos=screenWidth/18;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/18;
	}

	if(robRow==0){
			RobotYpixelPos=screenHeight/14;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/14;
	}

	switch(robHeading){
			case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");	break; // Facing North
			case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); break; // Facing East
			case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); break; // Facing South
			case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); break; // Facing West
			default: break;
	}
}
