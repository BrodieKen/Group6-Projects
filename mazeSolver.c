#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NORTH 0
#define EAST 1
#define SOUTH 2
#define WEST 3

int gridLength = 10;
int orientation = NORTH;
int motorSpeed = 10;

void turnRight();
void turnLeft();
void goFwd();
int checkPath();
void searchCross();
void CheckDirection();


int map[4][6];	//define size of map rows x columns



task main()
{
	resetGyro(gyroSensor);
	sleep(500); //wait half a second to get heading 0
	
	
	
}



//to track and draw the map as the robot goes we want to
//create a 2D array the size of the map, where each element indicates if a valid path exists
//a valid path is indicated as a 1 in the array and an invalid path is a 0
//we know where we start and where the end is, and we know the borders, there fore we can initialize an array as such below
//4x4 map example with 1 start 1 end
/*
Map with borders initialized with start and end
0	0	0	0	0	0
0	1	*	1	E	0
0	1	1	1	*	0
0	1	*	1	1	0
0	S	1	*	*	0
0	0	0	0	0	0
*/
//each star represents a path or line NOT A NODE/CROSS, this allows us to define yes or no lines to follow
//we start the robot in a position where it will search for lines from start, given that we know what each of those lines starting spots are
//we also know the end is at one position, where any of the connecting stars are valid. lets indicate them as 2 as to identify the goal


void checkDirection(){
	//this may or may not work. idk if i can set ranges inside a case structure
	//this is to quickly define the direction oyu are facing, call this and it reports the heading
	//will be used with decsion making, not nessessarily turing
	heading = getGyroHeading();
	switch(heading){
		case <= 0 || >= 350 : orientation = NORTH; break;
		case >= 80 && <= 100: orientation = EAST; break;
		case >= 170 && <= 190: orientation = SOUTH; break;
		case >= 260 && <= 280: orientation = NORTH; break;
		default: displayBigStringAt(screenHeight/2, screenWidth/2, "Orientation ERRORTEXT");
	}
}

int checkPath(){
	if(colorSensor<30){
		return 1;
	else if (colorSensor>30){
		return 0;
	}
}

void searchCross(){
//scan left and right of direction entered
//turn 90 degrees and scan left and right
//record if black was detected at each discrete point
//knowing which way was entered, add NORTH EAST SOUTH WEST if a point was found
	int scannedNums[4];
	int num1;
	int num2;
	
	//scan left and right. save 1/0 into respective position for direction scanned
	checkDirection();
	switch(orientation){
		case NORTH: setMotorTarget(armMotor,-30,50);scannedNums[WEST] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[EAST] = checkPath();setMotorTarget(armMotor,0,50);
		case EAST: setMotorTarget(armMotor,-30,50);scannedNums[NORTH] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[SOUTH] = checkPath();setMotorTarget(armMotor,0,50);
		case SOUTH: setMotorTarget(armMotor,-30,50);scannedNums[EAST] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[WEST] = checkPath();setMotorTarget(armMotor,0,50);
		case WEST: setMotorTarget(armMotor,-30,50);scannedNums[SOUTH] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[NORTH] = checkPath();setMotorTarget(armMotor,0,50);
		default: displayBigStringAt(screenHeight/2, screenWidth/2, "Orientation ERRORTEXT");
	
	//turn and scan
	resetMotorEncoder(armMotor);
	turnRight();	
	
	//scan left and right. save 1/0 into respective position for direction scanned
	checkDirection();
	switch(orientation){
		case NORTH: setMotorTarget(armMotor,-30,50);scannedNums[WEST] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[EAST] = checkPath();setMotorTarget(armMotor,0,50);
		case EAST: setMotorTarget(armMotor,-30,50);scannedNums[NORTH] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[SOUTH] = checkPath();setMotorTarget(armMotor,0,50);
		case SOUTH: setMotorTarget(armMotor,-30,50);scannedNums[EAST] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[WEST] = checkPath();setMotorTarget(armMotor,0,50);
		case WEST: setMotorTarget(armMotor,-30,50);scannedNums[SOUTH] = checkPath();setMotorTarget(armMotor,30,50);scannedNums[NORTH] = checkPath();setMotorTarget(armMotor,0,50);
		default: displayBigStringAt(screenHeight/2, screenWidth/2, "Orientation ERRORTEXT");

}

void goFwd(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,gridLength, motorSpeed);
	setMotorTarget(rightMotor,gridLength, motorSpeed);
}


void turnRight(){
	int initialPos  = getGyroHeading(gyroSensor);	//get current heading
	setMotorSpeed(leftMotor,motorSpeed);
	setMotorSpeed(rightMotor,-motorSpeed);
	waitUntil(getGyroHeading(gyroSensor) >= initialPos + 90);	//turn until 90 degrees
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
}
void turnLeft(){
	int initialPos  = getGyroHeading(gyroSensor);	//get current heading
	setMotorSpeed(leftMotor,-motorSpeed);
	setMotorSpeed(rightMotor,motorSpeed);
	waitUntil(getGyroHeading(gyroSensor) <= initialPos - 90);	//turn until 90 degrees
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
}
