#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//1 = line 0 = no line

#define NORTH 0
#define EAST 1
#define SOUTH 2
#define WEST 3

int gridLength = 20;
int orientation = NORTH;
int motorSpeed = 10;
int row = 0;
int col = 0;
int targetRow = 3;
int targetCol = 3;
int directionMarix[4][4];

void turnRight();
void turnLeft();
void goFwd();
int checkPath();
void searchCross();
void checkDirection();
void mazeInit();
void buildOuterWalls();
void 	populateDirectionMatrix();


struct mazeCell{
	int northWall;
	int eastWall;
	int southWall;
	int westWall;
	bool visited;
	bool bad;
	int options;
}

struct mazeCell Maze[6][8];


task main()
{
	while(true){
			setMotorTarget(armMotor,140, 5);
			waitUntilMotorStop(armMotor);
			setMotorTarget(armMotor,-140, 5);
			waitUntilMotorStop(armMotor);
	}


	//mazeInit();
	//buildOuterWalls();
	//populateDirectionMatrix();

	//resetGyro(gyroSensor);
	//sleep(500); //wait half a second to get heading 0

	//searchCross();

	//while(row!= targetRow && col!=targetCol){
	//	int rowDistance = targetRow - row;
	//	int colDistance = targetCol - col;
	//	int turns;
	//	if (abs(rowDistance) >= abs(colDistance)){
	//		if (rowDistance > 0 && Maze[row][col].eastWall == 1 && Maze[row+1][col].bad == false) {
	//			checkDirection();
	//			turns = directionMarix[orientation][EAST];
	//			for(int i = 0; i < turns; i++){
	//				turnRight();
	//			}
	//			if(turns == 2){
	//				Maze[row][col].bad = true;
	//			}
	//			row += 1;
	//			goFwd();
	//		}
	//		else if (rowDistance < 0 && Maze[row][col].westWall == 1 && Maze[row-1][col].bad == false){
	//			checkDirection();
	//			turns = directionMarix[orientation][WEST];
	//			for(int i = 0; i < turns; i++){
	//				turnRight();
	//			}
	//			if(turns == 2){
	//				Maze[row][col].bad = true;
	//			}
	//			row -= 1;
	//			goFwd();
	//		}
	//	}
	//	else{
	//		if (colDistance > 0 && Maze[row][col].northWall == 1 && Maze[row][col+1].bad == false) {
	//			checkDirection();
	//			turns = directionMarix[orientation][NORTH];
	//			for(int i = 0; i < turns; i++){
	//				turnRight();
	//			}
	//			if(turns == 2){
	//				Maze[row][col].bad = true;
	//			}
	//			col += 1;
	//			goFwd();
	//		}
	//		else if (colDistance < 0 && Maze[row][col].southWall == 1 && Maze[row][col-1].bad == false) {
	//			checkDirection();
	//			turns = directionMarix[orientation][SOUTH];
	//			for(int i = 0; i < turns; i++){
	//				turnRight();
	//			}
	//			if(turns == 2){
	//				Maze[row][col].bad = true;
	//			}
	//			col -= 1;
	//			goFwd();
	//		}
	//	}
	//}
}


/*----Initialization Functions----*/
void buildOuterWalls()
{
	//in memory
	Maze[0][0].westWall = 1;
	for(int row = 0; row <6;row++){
		Maze[row][0].westWall = 1;
		Maze[row][7].eastWall = 1;
	}
	for(int column = 0; column <6;column++){
		Maze[0][column].southWall = 1;
		Maze[5][column].northWall = 1;
	}

}

void populateDirectionMatrix(){
	/*
		0	1	2	3
		3	0	1	2
		2	3	0	1
		1	2	3	0
	*/
	//[current] [desired]
	directionMarix[0][0] = 0;
	directionMarix[0][1] = 1;
	directionMarix[0][2] = 2;
	directionMarix[0][3] = 3;
	directionMarix[1][0] = 3;
	directionMarix[1][1] = 0;
	directionMarix[1][2] = 1;
	directionMarix[1][3] = 2;
	directionMarix[2][0] = 2;
	directionMarix[2][1] = 3;
	directionMarix[2][2] = 0;
	directionMarix[2][3] = 1;
	directionMarix[3][0] = 1;
	directionMarix[3][1] = 2;
	directionMarix[3][2] = 3;
	directionMarix[3][3] = 0;
}

void mazeInit()
{
	for(int row = 0; row < 6; row++){
		for( int column = 0; column < 8; column++){
			Maze[row][column].northWall = 0;		//0 = no wall, 1 = wall
			Maze[row][column].eastWall = 0;
			Maze[row][column].southWall = 0;
			Maze[row][column].westWall = 0;
			Maze[row][column].visited = false;
			Maze[row][column].bad = false;
			Maze[row][column].options = 0;
		}
	}
}



/*----path checking functions----*/

void checkDirection(){
//find what direction we are facing
	if(getGyroHeading(gyroSensor)<= 45 && getGyroHeading(gyroSensor)>-45){
		orientation = NORTH;
	}
	else if(getGyroHeading(gyroSensor)> 45 && getGyroHeading(gyroSensor)<= 135){
		orientation = WEST;
	}
	else if(getGyroHeading(gyroSensor)> 135 || getGyroHeading(gyroSensor)<= -135){
		orientation = SOUTH;
	}
	else if(getGyroHeading(gyroSensor)> -135 && getGyroHeading(gyroSensor)<= -45){
		orientation = EAST;
	}
}


int checkPath(){
	if(getColorReflected(colorSensor)<30){
		return 1;
	}
	else {
		return 0;
	}
}

void searchCross(){
//scan left and right of direction entered
//move forward scan
//record if black was detected at each discrete point

	//scan left and right. save 1/0 into respective position for direction scanned
	checkDirection();
	switch(orientation){
		case NORTH: setMotorTarget(armMotor,-30,50);Maze[row][col].westWall = checkPath();setMotorTarget(armMotor,30,50);Maze[row][col].eastWall = checkPath();setMotorTarget(armMotor,0,50);
		case EAST: setMotorTarget(armMotor,-30,50);Maze[row][col].northWall = checkPath();setMotorTarget(armMotor,30,50);Maze[row][col].southWall = checkPath();setMotorTarget(armMotor,0,50);
		case SOUTH: setMotorTarget(armMotor,-30,50);Maze[row][col].eastWall = checkPath();setMotorTarget(armMotor,30,50);Maze[row][col].westWall = checkPath();setMotorTarget(armMotor,0,50);
		case WEST: setMotorTarget(armMotor,-30,50);Maze[row][col].southWall = checkPath();setMotorTarget(armMotor,30,50);Maze[row][col].northWall = checkPath();setMotorTarget(armMotor,0,50);
		default: displayBigStringAt(117/2, 177/2, "Orientation ERRORTEXT");
	}

	resetMotorEncoder(armMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	//scan forwards. save 1/0 into respective position for direction scanned
	switch(orientation){
		case NORTH: setMotorTarget(leftMotor,10,motorSpeed);setMotorTarget(rightMotor,10,motorSpeed);waitUntilMotorStop(leftMotor);
								//scan from line track project
								Maze[row][col].northWall = checkPath();Maze[row][col].southWall = 1;
								setMotorTarget(leftMotor,0,-motorSpeed);setMotorTarget(rightMotor,0,-motorSpeed);waitUntilMotorStop(leftMotor);
		case EAST: setMotorTarget(leftMotor,10,motorSpeed);setMotorTarget(rightMotor,10,motorSpeed);waitUntilMotorStop(leftMotor);
								//scan from line track project
								Maze[row][col].eastWall = checkPath();Maze[row][col].westWall = 1;
								setMotorTarget(leftMotor,0,-motorSpeed);setMotorTarget(rightMotor,0,-motorSpeed);waitUntilMotorStop(leftMotor);
		case SOUTH: setMotorTarget(leftMotor,10,motorSpeed);setMotorTarget(rightMotor,10,motorSpeed);waitUntilMotorStop(leftMotor);
								//scan from line track project
								Maze[row][col].southWall = checkPath();Maze[row][col].northWall = 1;
								setMotorTarget(leftMotor,0,-motorSpeed);setMotorTarget(rightMotor,0,-motorSpeed);waitUntilMotorStop(leftMotor);
		case WEST: setMotorTarget(leftMotor,10,motorSpeed);setMotorTarget(rightMotor,10,motorSpeed);waitUntilMotorStop(leftMotor);
								//scan from line track project
								Maze[row][col].westWall = checkPath();Maze[row][col].eastWall = 1;
								setMotorTarget(leftMotor,0,-motorSpeed);setMotorTarget(rightMotor,0,-motorSpeed);waitUntilMotorStop(leftMotor);
		default: displayBigStringAt(117/2, 177/2, "Orientation ERRORTEXT");
	}
	Maze[row][col].options = Maze[row][col].northWall + Maze[row][col].eastWall + Maze[row][col].southWall + Maze[row][col].westWall;

}



/*----Motion Functions----*/
void goFwd(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,gridLength, motorSpeed);
	setMotorTarget(rightMotor,gridLength, motorSpeed);
	waitUntilMotorStop(leftMotor);

}


void turnRight(){
	int initialPos  = getGyroHeading(gyroSensor);	//get current heading
	setMotorSpeed(leftMotor,motorSpeed);
	setMotorSpeed(rightMotor,-motorSpeed);
	waitUntil(getGyroHeading(gyroSensor) >= initialPos + 90);	//turn until 90 degrees
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
}
void turnLeft(){
	int initialPos  = getGyroHeading(gyroSensor);	//get current heading
	setMotorSpeed(leftMotor,-motorSpeed);
	setMotorSpeed(rightMotor,motorSpeed);
	waitUntil(getGyroHeading(gyroSensor) <= initialPos - 90);	//turn until 90 degrees
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
}
