#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/* what it does
- calculates optimal path 100% done
- saves this path in PathTaken, has random 9s where values are eliminated
*/
/* Todo
- figure out how to ignore said 9s
- detect whether to drive straight or line track
		- checking next and current paths
- line track
- stop line tracking when turned 90 degrees
- keep track of current row and col to know when to STOP
- expand maze to biiiiiig size
*/
const int screenHeight = 127;
const int screenWidth  = 177;
const int numOfRows = 4;
const int numOfCols = 5;

int startRow = 0;
int startCol = 1;
int targetRow = 0;
int targetCol = 3;
int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
int robRow = startRow;
int robCol = startCol;
int orientation = 0;
int gridLength = 1500;
int motorSpeed = 25;


typedef struct{
	int nWall;  // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;

}cell;

cell maze[numOfRows][numOfCols];

int pathIndex = 0;
int pathTaken[30];
int directionMarix[4][4];


void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void MazeSim();
void refreshScreen();
void solveMazeRWF();
void optimizePath();
void populateDirectionMatrix();
void goFwdIRL();
void turnRightIRL();
void checkDirection();

task virtualFollow();


task main(){
	//initialize maze and solve virtually
	for (int i = 0; i<30;i++){
		pathTaken[i] = 9;
	}
	buildOuterBorders();
	MazeSim();
	refreshScreen(robHeading);
	while(robRow!= targetRow || robCol != targetCol){
		solveMazeRWF();
		refreshScreen(robHeading);
		//sleep(250);
	}
	refreshScreen(robHeading);
	optimizePath();
	sleep(1000);


	//follow optimized path
	populateDirectionMatrix();
	resetGyro(gyroSensor);
	sleep(500); //wait half a second to get heading 0
	startTask(virtualFollow);
	for (int i = 0; i < pathIndex; i++){
		if (pathTaken[i] != 9) {
			checkDirection();
			for (int j=0; j < directionMarix[orientation][pathTaken[i]]; j++){
				turnRightIRL();
			}
			goFwdIRL();
		}
	}

	//for (int i = 0; i < pathIndex; i++){

	/*
	for pathIndex
		currentPath
		nextPath

		if currentPath = nextPath
			move encoder distance
		else if current path != nextPath
			if turn right?
				line track right until orientation changed
			else if turn left?
				line track until orientation changed

	*/
}




//===Virtual following of the physical robot===//
task virtualFollow(){\
	robRow = startRow;	//increment robRow and robCol whenever the current spot in the path changes
	robCol = startCol;
	//current Path index is the current spot the robot is at in the optimized path
	while(currentPathIndex < pathIndex){
		checkDirection();
		switch(pathTaken[pathIndex]){
			case 0: robRow++;break;
			case 1: robCol++;break;
			case 2: robRow--;break;
			case 3: robCol--;break;
			default: break;
		}
		refreshScreen(orientation);
	}
	//get the orientation
	//get the position in the matrix
	//display the position and refresh screen
}




/*----path checking functions----*/

void checkDirection(){
//find what direction we are facing
	if(getGyroHeading(gyroSensor)<= 45 && getGyroHeading(gyroSensor)>-45){
		orientation = 0;
	}
	else if(getGyroHeading(gyroSensor)> 45 && getGyroHeading(gyroSensor)<= 135){
		orientation = 3;
	}
	else if(getGyroHeading(gyroSensor)> 135 || getGyroHeading(gyroSensor)<= -135){
		orientation = 2;
	}
	else if(getGyroHeading(gyroSensor)> -135 && getGyroHeading(gyroSensor)<= -45){
		orientation = 1;
	}
}




/*----Motion Functions----*/
void goFwdIRL(){

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,gridLength, motorSpeed);
	setMotorTarget(rightMotor,gridLength, motorSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);

}


void turnRightIRL(){
	int initialPos  = getGyroDegrees(gyroSensor);	//get current heading
	setMotorSpeed(leftMotor,-motorSpeed);
	setMotorSpeed(rightMotor,motorSpeed);
	waitUntil(getGyroDegrees(gyroSensor) <= initialPos - 90);	//turn until 90 degrees
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	waitUntilMotorStop(leftMotor);
}

void populateDirectionMatrix(){
	/*
		0	1	2	3
		3	0	1	2
		2	3	0	1
		1	2	3	0
	*/
	//[current] [desired]
	directionMarix[0][0] = 0;
	directionMarix[0][1] = 1;
	directionMarix[0][2] = 2;
	directionMarix[0][3] = 3;
	directionMarix[1][0] = 3;
	directionMarix[1][1] = 0;
	directionMarix[1][2] = 1;
	directionMarix[1][3] = 2;
	directionMarix[2][0] = 2;
	directionMarix[2][1] = 3;
	directionMarix[2][2] = 0;
	directionMarix[2][3] = 1;
	directionMarix[3][0] = 1;
	directionMarix[3][1] = 2;
	directionMarix[3][2] = 3;
	directionMarix[3][3] = 0;
}











/*-------Virtual Optimization of path functions---*/

//solve and optimization functions//
void optimizePath(){
	//this will modify the path taken to be the fastest path
	for(int i = 0; i <= pathIndex; i++){
		switch(pathTaken[i]){
			case 0: if(pathTaken[i+1] == 2){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 1:	if(pathTaken[i+1] == 3){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 2:	if(pathTaken[i+1] == 0){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 3:	if(pathTaken[i+1] == 1){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			default: break;
		}
	}
}

void solveMazeRWF(){
	// solve the maze using RWF method. for LWF swap left and right turns
	turnRight();
	bool moved = false;
	while(moved == false){
		switch (robHeading){
			case 0: if(maze[robRow][robCol].nWall == 0){goFwd();moved = true; }else {turnLeft();} break;
			case 1: if(maze[robRow][robCol].eWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			case 2:	if(maze[robRow][robCol].sWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			case 3:	if(maze[robRow][robCol].wWall == 0){goFwd();moved = true;}else {turnLeft();}break;
			default: break;

		}
	}
}


//mazze building functions//
void MazeSim(){
	//column 0
	maze[0][0].eWall = maze[0][1].wWall = 1;
	maze[0][0].nWall = maze[1][0].sWall = 1;
	maze[1][0].nWall = maze[2][0].sWall = 1;
	maze[2][0].nWall = maze[3][0].sWall = 1;
	maze[3][0].eWall = maze[3][1].wWall = 1;

	//column 1
	maze[0][1].eWall = maze[0][2].wWall = 1;
	maze[1][1].eWall = maze[1][2].wWall = 1;
	maze[2][1].nWall = maze[3][1].sWall = 1;
	maze[3][1].eWall = maze[3][2].wWall = 1;

		//column 2
	maze[0][2].eWall = maze[0][3].wWall = 1;
	maze[0][2].nWall = maze[1][2].sWall = 1;
	maze[1][2].nWall = maze[2][2].sWall = 1;
	maze[2][2].nWall = maze[3][2].sWall = 1;
	maze[3][2].eWall = maze[3][3].wWall = 1;

		//column 3
	maze[0][3].eWall = maze[0][4].wWall = 1;
	maze[3][3].eWall = maze[3][4].wWall = 1;

	//column 4
	maze[0][4].nWall = maze[1][4].sWall = 1;
	maze[1][4].nWall = maze[2][4].sWall = 1;
	maze[2][4].nWall = maze[3][4].sWall = 1;
}

void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		maze[0][col].sWall = 1;
		maze[numOfRows-1][col].nWall = 1;
	}

	for(int row=0; row<numOfRows; row++){
		maze[row][0].wWall = 1;
		maze[row][numOfCols-1].eWall = 1;
	}
}

void refreshScreen(int robDirect){
	eraseDisplay();
	gridDraw();
	drawBot(robDirect);
}


//virtual Motion functions//
void goFwd(){
	//wait1Msec(1000);  // waste some time to simulate motion
	if (robHeading==0)	{   // Going Fwd North
		robRow++;
	}
	else if (robHeading==1)	{   // Going Fwd East
		robCol++;
	}
	else if (robHeading==2)	{   // Going Fwd South
		robRow--;
	}
	else if (robHeading==3)	{   // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	pathTaken[pathIndex] = robHeading;
	pathIndex++;

}

void turnRight(){
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}

void turnLeft(){
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}







//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd  =0;
	int YEnd  =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(maze[i][j].nWall==1){
					XStart= j   *screenWidth/numOfCols;
					YStart=(i+1)*screenHeight/numOfRows;
					XEnd  =(j+1)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].eWall==1){
					XStart=(j+1)*screenWidth/numOfCols;
					YStart=(i)*screenHeight/numOfRows;
					XEnd  =(j+1)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].wWall==1){
					XStart= j   *screenWidth/numOfCols;
					YStart=(i)*screenHeight/numOfRows;
					XEnd  =(j)*screenWidth/numOfCols;
					YEnd  =(i+1)*screenHeight/numOfRows;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(maze[i][j].sWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}

//=====================================================================
void drawBot(int robDirect){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;

	if(robCol==0){
			RobotXpixelPos=screenWidth/10;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/10;
	}

	if(robRow==0){
			RobotYpixelPos=screenHeight/8;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/8;
	}

	switch(robDirect){
			case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");	break; // Facing North
			case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); break; // Facing East
			case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); break; // Facing South
			case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); break; // Facing West
			default: break;
	}
}
