#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int screenHeight = 127;
const int screenWidth  = 177;
const int numOfRows = 8;
const int numOfCols = 10;

int startRow = 3;
int startCol = 1;
int targetRow = 0;
int targetCol =9;
int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
int robRow = startRow;
int robCol = startCol;
int gridLength =	654; //328;
int turnTarget = 58;//150;	//found through experimentation rather than calulcation
float motorSpeed = 25;
int turnSpeed = 5;
const int arrayLength = 100;
int targetColor = 15; //set based on starting point (black or yellow) 21 yellow or 15 black
int color;
int alignmentVal = 1;
bool calcStatus = false;

typedef struct{
	int nWall;  // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;
	int color;

}cell;

cell maze[numOfRows][numOfCols];

int pathIndex = 0;
int pathTaken[arrayLength];
int directionMarix[4][4];


void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void MazeSim();
void refreshScreen();
void solveMazeRWF();
void optimizePath();
void populateDirectionMatrix();
void goFwdIRL();
void turnRightIRL();
void turnLeftIRL();
void inputStartAndEnd();




task main(){

	setLEDColor(ledRedPulse);

	//initialize maze and solve virtually
	for (int i = 0; i<arrayLength;i++){
		pathTaken[i] = 9;
	}
	//inputStartAndEnd();	//Comment out for manual input from the code for start and end positions
	buildOuterBorders();
	MazeSim();
	refreshScreen();
	while(robRow!= targetRow || robCol != targetCol){
		solveMazeRWF();
		refreshScreen();
		sleep(10);
	}
	refreshScreen();
	optimizePath();
	populateDirectionMatrix();
	sleep(1000);

	playSound(soundDownwardTones);
	setLEDColor(ledOrangePulse);
	calcStatus = true;

	//follow optimized path
	pathIndex = 0;
	robRow = startRow;
	robCol = startCol;
	robHeading = 0;
	refreshScreen();

	//orient to starting line
	if(robHeading != pathTaken[pathIndex]){
		int rotateTo = directionMarix[robHeading][pathTaken[pathIndex]];
		for(int j = 0; j< abs(rotateTo);j++){
			if(rotateTo > 0){	//right
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);
				setMotorTarget(leftMotor,150,turnSpeed);
				setMotorTarget(rightMotor,-150,turnSpeed);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				switch(robHeading){
				case 0: robHeading = 1;break;
				case 1: robHeading = 2;break;
				case 2: robHeading = 3;break;
				case 3: robHeading = 0;break;
				default: break;
				}
			}
			else if(rotateTo <0){	//left
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);
				setMotorTarget(leftMotor,-150,turnSpeed);
				setMotorTarget(rightMotor,150,turnSpeed);
				waitUntilMotorStop(leftMotor);
				waitUntilMotorStop(rightMotor);
				resetMotorEncoder(leftMotor);
				resetMotorEncoder(rightMotor);

				switch(robHeading){
				case 0: robHeading = 3;break;
				case 1: robHeading = 0;break;
				case 2: robHeading = 1;break;
				case 3: robHeading = 2;break;
				default: break;
				}
			}
		}
	}

	//folow lines from path Taken
	while(robRow != targetRow || robCol != targetCol){

		if (robCol == 4 && pathTaken[pathIndex] != 3){
			targetColor = 21; //yellow value
			alignmentVal = -1;
		}
		else if (robCol == 4 && pathTaken[pathIndex] == 3) {
			targetColor = 15; //black value
			alignmentVal = 1;
		}

		if(robHeading != pathTaken[pathIndex]){
			int rotateTo = directionMarix[robHeading][pathTaken[pathIndex]];
			for(int j = 0; j< abs(rotateTo);j++){
				if(rotateTo > 0){
					turnRightIRL();
				}
				else if(rotateTo <0){
					turnLeftIRL();
				}
			}
		}
		else{
			goFwdIRL();
			pathIndex++;
		}
		refreshScreen();
	}

	//The robot will sound a different tone for 2 seconds, or indicate on the robot screen when it believes that it has reached the target coordinates.
	playSound(soundFastUpwardTones);
	playSound(soundBlip);
	playSound(soundBeepBeep);
	eraseDisplay();
	while(true) {
		displayCenteredBigTextLine(5, "Destination");
		displayCenteredBigTextLine(7, "Reached");
		setLEDColor(ledGreen);
		wait10Msec(50);
		setLEDColor(ledOrange);
		eraseDisplay();
		wait10Msec(50);
	}


}

///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////

/*----Motion Functions----*/
void goFwdIRL(){
	float pConst = 0.75;
	float iConst = 0;
	float dConst = 0;
	float Error = 0;
	float lastError = 0;
	float integral = 0;
	float derivative;
	float pValue;
	float iValue;
	float dValue;
	bool integralInitiation = false;

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);


	while ((getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor))/2 < (gridLength)*(0.6)){

		//Standard PID loop algorithm. compares current value of color sensor to the desired value of color sensor and adjusts motor speeds proportionally

		color = getColorReflected(colorSensor);

		//calculate error by comparing color sensor to the desired value of color sensor
		Error = color - targetColor;

		//intiate integral counting once the line has been found to track (baseline)
		if (Error <= 15 && Error >=  -15){
			integralInitiation = true;
		}
		if (integralInitiation == true && Error < 25 ) {	//25 is max error allowed to prevent run away
			integral += Error;    //intregral is sum of past errors
		}

		//predict where robot is heading based on rate of change between current and previous error
		derivative = Error - lastError;
		lastError = Error;

		//convert color sensor values to speed values using optimized constants
		pValue = pConst*Error;
		iValue = iConst*integral;
		dValue = dConst*derivative;

		//set PID drive adjustment
		float pidDrive = pValue +iValue + dValue;

		//set motor speeds
		setMotorSpeed(rightMotor, motorSpeed - alignmentVal*pidDrive);
		setMotorSpeed(leftMotor, motorSpeed + alignmentVal*pidDrive);
	}
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,gridLength*0.4,motorSpeed);
	setMotorTarget(rightMotor,gridLength*0.4,motorSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);


	switch(robHeading){
	case 0: 	robRow++;break;
	case 1:   robCol++;break;
	case 2:   robRow--;break;
	case 3:   robCol--;break;
	default: break;
	}
}







void turnRightIRL(){
	//float pConst = 0;
	//float pValue;
	//float Error;

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	while((abs(getMotorEncoder(leftMotor))<turnTarget&&abs(getMotorEncoder(leftMotor))<turnTarget)||(getColorReflected(colorSensor) > targetColor + 2 || getColorReflected(colorSensor) < targetColor - 2)){
		//might be able to make something of this.
		//was attempting to proportionally decrease speed as we approach were we think the line is
		//color = getColorReflected(colorSensor);
		//Error = color - targetColor; //(abs(getMotorEncoder(leftMotor))+abs(getMotorEncoder(rightMotor)))/2 - turnTarget;

		//pValue = pConst*Error;

		setMotorSpeed(leftMotor,turnSpeed);	 		//+ pValue);
		setMotorSpeed(rightMotor,-turnSpeed);		//-pValue);
	}
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	switch(robHeading){
	case 0: robHeading = 1;break;
	case 1: robHeading = 2;break;
	case 2: robHeading = 3;break;
	case 3: robHeading = 0;break;
	default: break;
	}
}

void turnLeftIRL(){
	/*
	One issue with left turns is that it can under turn causing it to miss algin with the next straight part.
	one way around this is to left turn in two steps
	1. turn way past the line as you know a rough estimate as to where the line should be
	2. turn right until you find the line again
	one issue i have with this is the edge case of over turning not actually aligning
	you on the side of the line you expect to be aligned on. Thus i didnt do that and just have it hope for the best
	*/

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	while((abs(getMotorEncoder(leftMotor))<3*turnTarget&&abs(getMotorEncoder(leftMotor))<3*turnTarget)){
		setMotorSpeed(leftMotor,-turnSpeed);
		setMotorSpeed(rightMotor,turnSpeed);
	}
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
	while(getColorReflected(colorSensor) > targetColor + 2 || getColorReflected(colorSensor) < targetColor - 2){
		int coloooor = getColorReflected(colorSensor);
		setMotorSpeed(leftMotor,turnSpeed);
		setMotorSpeed(rightMotor,-turnSpeed);
		displayCenteredBigTextLine(3, "Target: %d", targetColor);
		displayCenteredBigTextLine(5, "Sensor: %d", coloooor);
	}
	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	switch(robHeading){
	case 0: robHeading = 3;break;
	case 1: robHeading = 0;break;
	case 2: robHeading = 1;break;
	case 3: robHeading = 2;break;
	default: break;
	}
}




void populateDirectionMatrix(){
	/*
	0	1	2	-1
	-1	0	1	2
	2	-1	0	1
	1	2	-1	0
	*/
	//[current] [desired]
	directionMarix[0][0] = 0;
	directionMarix[0][1] = 1;
	directionMarix[0][2] = 2;
	directionMarix[0][3] = -1;
	directionMarix[1][0] = -1;
	directionMarix[1][1] = 0;
	directionMarix[1][2] = 1;
	directionMarix[1][3] = 2;
	directionMarix[2][0] = 2;
	directionMarix[2][1] = -1;
	directionMarix[2][2] = 0;
	directionMarix[2][3] = 1;
	directionMarix[3][0] = 1;
	directionMarix[3][1] = 2;
	directionMarix[3][2] = -1;
	directionMarix[3][3] = 0;
}

/*-------Virtual Optimization of path functions---*/

//solve and optimization functions//
void optimizePath(){
	//this will modify the path taken to be the fastest path
	for (int optimizeIterations = 0; optimizeIterations<arrayLength;optimizeIterations++) {
		for(int i = 0; i <= pathIndex; i++){
			switch(pathTaken[i]){
			case 0: if(pathTaken[i+1] == 2){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 1:	if(pathTaken[i+1] == 3){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 2:	if(pathTaken[i+1] == 0){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			case 3:	if(pathTaken[i+1] == 1){pathTaken[i] = 9; pathTaken[i+1] = 9;}break;
			default: break;
			}
		}
		int newPathTaken[arrayLength];
		for (int j = 0; j<arrayLength;j++){
			newPathTaken[j] = 9;
		}
		int newStepCount = 0;
		for(int k = 0; k <= pathIndex; k++){
			if(pathTaken[k] != 9) {
				newPathTaken[newStepCount] = pathTaken[k];
				newStepCount++;
			}
		}
		for (int l = 0; l<arrayLength;l++){
			pathTaken[l] = newPathTaken[l];
		}
	}
}

void solveMazeRWF(){
	// solve the maze using RWF method. for LWF swap left and right turns
	turnRight();
	bool moved = false;
	while(moved == false){
		switch (robHeading){
		case 0: if(maze[robRow][robCol].nWall == 0){goFwd();moved = true; }else {turnLeft();} break;
		case 1: if(maze[robRow][robCol].eWall == 0){goFwd();moved = true;}else {turnLeft();}break;
		case 2:	if(maze[robRow][robCol].sWall == 0){goFwd();moved = true;}else {turnLeft();}break;
		case 3:	if(maze[robRow][robCol].wWall == 0){goFwd();moved = true;}else {turnLeft();}break;
		default: break;

		}
	}
}

//mazze building functions//
void inputStartAndEnd(){
	int num = 0;
	int settings = 0;
	int buttonState = 0;
	while(settings < 5){
		if(getButtonPress(buttonUp) == true){
			num++;
		}
		else if(getButtonPress(buttonDown) == true){
			num--;
		}
		switch(settings){
		case 0:	//robot start row
			if(num>7){num = 0;}
			else if(num<0){num = 7;}
			startRow = num;
			break;
		case 1:	//robot start col
			if(num>9){num = 0;}
			else if(num<0){num = 9;}
			startCol = num;
			break;
		case 2:	//robot target row
			if(num>7){num = 0;}
			else if(num<0){num = 7;}
			targetRow = num;
			break;
		case 3:	//robot target col
			if(num>7){num = 0;}
			else if(num<0){num = 7;}
			targetCol = num;
			break;
		case 4:	//confirm ready to begin
			waitForButtonPress();
			settings++;
			break;//when enter button released, switch to next setting
		default: break;
		}
		displayTextLine(1, "Robot Start Row: %d",startRow);
		displayTextLine(3, "Robot Start Column: %d",startCol);
		displayTextLine(5, "Robot Target Row: %d",targetRow);
		displayTextLine(7, "Robot Target Column: %d",targetCol);

		if (getButtonPress(buttonEnter)== 1 && buttonState == 0){
			settings++;	//when enter button released, switch to next setting
			buttonState = 1;
		}
		else if(getButtonPress(buttonEnter)== 0 && buttonState == 1){
			buttonState = 0;
		}
		wait1Msec(100);
	}
}


void MazeSim(){

	//column 0
	maze[7][0].sWall = maze[6][0].nWall = 1;
	maze[6][0].sWall = maze[5][0].nWall = 1;
	maze[5][0].sWall = maze[4][0].nWall = 1;
	maze[4][0].sWall = maze[3][0].nWall = 1;
	maze[3][0].sWall = maze[2][0].nWall = 1;
	maze[2][0].sWall = maze[1][0].nWall = 1;
	maze[2][0].sWall = maze[0][0].nWall = 1;

	maze[1][0].eWall = maze[1][1].wWall = 1;
	maze[4][0].eWall = maze[4][1].wWall = 1;
	maze[6][0].eWall = maze[6][1].wWall = 1;

	//column 1
	maze[6][1].sWall = maze[5][1].nWall = 1;
	maze[5][1].sWall = maze[4][1].nWall = 1;
	maze[3][1].sWall = maze[2][1].nWall = 1;
	maze[2][1].sWall = maze[1][1].nWall = 1;

	maze[7][1].eWall = maze[7][2].wWall = 1;
	maze[3][1].eWall = maze[3][2].wWall = 1;
	maze[0][1].eWall = maze[0][2].wWall = 1;

	//column 2
	maze[7][2].eWall = maze[7][3].wWall = 1;
	maze[6][2].eWall = maze[6][3].wWall = 1;
	maze[3][2].eWall = maze[3][3].wWall = 1;
	maze[0][2].eWall = maze[0][3].wWall = 1;

	//column 3
	maze[7][3].sWall = maze[6][3].nWall = 1;
	maze[6][3].sWall = maze[5][3].nWall = 1;
	maze[5][3].sWall = maze[4][3].nWall = 1;
	maze[3][3].sWall = maze[2][3].nWall = 1;
	maze[2][3].sWall = maze[1][3].nWall = 1;
	maze[1][3].sWall = maze[0][3].nWall = 1;

	maze[7][3].eWall = maze[7][4].wWall = 1;
	maze[6][3].eWall = maze[6][4].wWall = 1;
	maze[4][3].eWall = maze[4][4].wWall = 1;
	maze[0][3].eWall = maze[0][4].wWall = 1;

	//column 4
	maze[7][4].sWall = maze[6][4].nWall = 1;
	maze[4][4].sWall = maze[3][4].nWall = 1;
	maze[3][4].sWall = maze[2][4].nWall = 1;
	maze[2][4].sWall = maze[1][4].nWall = 1;

	maze[7][4].eWall = maze[7][5].wWall = 1;
	maze[4][4].eWall = maze[4][5].wWall = 1;
	maze[1][4].eWall = maze[1][5].wWall = 1;

	//column 5
	maze[6][5].sWall = maze[5][5].nWall = 1;
	maze[5][5].sWall = maze[4][5].nWall = 1;
	maze[3][5].sWall = maze[2][5].nWall = 1;
	maze[2][5].sWall = maze[1][5].nWall = 1;

	maze[7][5].eWall = maze[7][6].wWall = 1;
	maze[6][5].eWall = maze[6][6].wWall = 1;
	maze[5][5].eWall = maze[5][6].wWall = 1;
	maze[4][5].eWall = maze[4][6].wWall = 1;
	maze[1][5].eWall = maze[1][6].wWall = 1;
	maze[0][5].eWall = maze[0][6].wWall = 1;

	//column 6
	maze[3][6].sWall = maze[2][6].nWall = 1;
	maze[2][6].sWall = maze[1][6].nWall = 1;

	maze[7][6].eWall = maze[7][7].wWall = 1;
	maze[6][6].eWall = maze[6][7].wWall = 1;
	maze[5][6].eWall = maze[5][7].wWall = 1;
	maze[4][6].eWall = maze[4][7].wWall = 1;
	maze[3][6].eWall = maze[3][7].wWall = 1;

	//column 7
	maze[1][7].sWall = maze[0][7].nWall = 1;

	maze[7][7].eWall = maze[7][8].wWall = 1;
	maze[6][7].eWall = maze[6][8].wWall = 1;
	maze[4][7].eWall = maze[4][8].wWall = 1;
	maze[3][7].eWall = maze[3][8].wWall = 1;
	maze[1][7].eWall = maze[1][8].wWall = 1;


	//column 8
	maze[7][8].sWall = maze[6][8].nWall = 1;
	maze[6][8].sWall = maze[5][8].nWall = 1;
	maze[5][8].sWall = maze[4][8].nWall = 1;
	maze[3][8].sWall = maze[2][8].nWall = 1;
	maze[1][8].sWall = maze[0][8].nWall = 1;

	maze[7][8].eWall = maze[7][9].wWall = 1;
	maze[3][8].eWall = maze[3][8].wWall = 1;
	maze[1][8].eWall = maze[1][9].wWall = 1;

	//column 9
	maze[7][9].sWall = maze[6][9].nWall = 1;
	maze[4][9].sWall = maze[3][9].nWall = 1;
	maze[3][9].sWall = maze[2][9].nWall = 1;
	maze[2][9].sWall = maze[1][9].nWall = 1;
	maze[1][9].sWall = maze[0][9].nWall = 1;

	for(int i = 0; i <numOfCols;i++){
		for(int j =0; j<numOfRows;j++){
			if(i>4){
				maze[j][i].color = 40; //yellow
			}
			else{
				maze[j][i].color = 5; //black
			}
		}
	}
}

void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		maze[0][col].sWall = 1;
		maze[numOfRows-1][col].nWall = 1;
	}

	for(int row=0; row<numOfRows; row++){
		maze[row][0].wWall = 1;
		maze[row][numOfCols-1].eWall = 1;
	}
}

void refreshScreen(){
	eraseDisplay();
	gridDraw();
	drawBot();
	if (calcStatus == true) {
		displayTextLine(1, "Optimal Path Found");
	}
}


//virtual Motion functions//
void goFwd(){
	//wait1Msec(1000);  // waste some time to simulate motion
	if (robHeading==0)	{   // Going Fwd North
		robRow++;
	}
	else if (robHeading==1)	{   // Going Fwd East
		robCol++;
	}
	else if (robHeading==2)	{   // Going Fwd South
		robRow--;
	}
	else if (robHeading==3)	{   // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	pathTaken[pathIndex] = robHeading;
	pathIndex++;

}

void turnRight(){
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}

void turnLeft(){
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}

//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd  =0;
	int YEnd  =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(maze[i][j].nWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i+1)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].eWall==1){
				XStart=(j+1)*screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].wWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(maze[i][j].sWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}

//=====================================================================
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;

	if(robCol==0){
		RobotXpixelPos=screenWidth/20;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/20;
	}

	if(robRow==0){
		RobotYpixelPos=screenHeight/16;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/16;
	}

	switch(robHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");	break; // Facing North
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); break; // Facing East
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); break; // Facing South
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); break; // Facing West
	default: break;
	}
}
