#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//define variables and constants
const int dataPoints = 7;
long barLengths[dataPoints];
int i = 0;
int colorCheck = 0;
bool blackFlag = true;
bool whiteFlag = false;

void record(){
	//records the current encoder value into an array of data
	barLengths[i] = getMotorEncoder(leftMotor);
	resetMotorEncoder(leftMotor);
}


void decodeData(){
	//This function decodes the data found in the reorded barlengths and displays it on the screenw hent he scanning is complete

	//threshold to define a thick line from a thin line (averaged mid point of all the lines recorded)
	float threshold = (barLengths[0]+barLengths[1])/2;

	short binVal[4];

	int j = 0;
	for (int i = 0;i<dataPoints;i+=2){
		//step through all the even data points since black lines are only located on even array values
		//compare each data point to the threshold and determine if thick or thin line. place in binary digit array
		if (barLengths[i]>threshold){
			binVal[j] = 1;
		}
		else{
			binVal[j] = 0;
		}
		j++;
	}


	int answer = 0;
	for(int k = 0; k<4; k++){
		//converts binary to decimal in reverse since plessey is reverse binary
		if (binVal[k] == 1){
			answer = answer + pow(2,k);
		}
	}
  displayCenteredBigTextLine(5,"%d", answer);
}



task main()	{

	//color sensor needs extra time to startup and begins reading black, even if it shouldnt. Start color sensor before looking at values
	colorCheck = getColorReflected(colorSensor);

	setMotorSpeed(leftMotor, 10);
	setMotorSpeed(rightMotor, 10);

	resetMotorEncoder(leftMotor);

	while(true) {

		if (getColorReflected(colorSensor) < 20){
				//wait until black is detected (start of barcode) then record data
				resetMotorEncoder(leftMotor);
				break;
			}
		}

	//set motors to slower speed to read barcode accuratly
	setMotorSpeed(leftMotor, 5);
	setMotorSpeed(rightMotor, 5);

	while(i<dataPoints){
	//Begining of barcode reading state machine
	//start with falgs of Black = true, White = False to begin on black part of  barcode

		colorCheck = getColorReflected(colorSensor);

		//check current color. if color is black, and was white, swap flags and record
		//if color is black and was black, skip
		if (colorCheck <15){
			if (blackFlag == false){
				blackFlag = true;
				whiteFlag = false;
				record();
				i++;
			}
		}

		//check current color. if color is white, and was black, swap flags and record
		//if color is white and was white, skip
		if (colorCheck >25){
			if (whiteFlag == false){
				blackFlag = false;
				whiteFlag = true;
				record();
				i++;
			}
		}
	}

	//clear data log and import data from array to export as csv for MATLAB code
	datalogClear();
	datalogDataGroupStart();
	for (int k = 0;k<dataPoints;k++){
			datalogAddValue(k,barLengths[k]);
	}
	datalogDataGroupEnd();

	//stop robot and decode
	decodeData();
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	wait1Msec(2000);


}
