#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variables

int allignmentVal;
int targetColor = 15;
int rightMtrSpd;
int leftMtrSpd;
const int speed = 25;

int red;
int blue;
int green;

void pickUp() {
	setMotorTarget(armMotor, 90, 30);
	waitUntilMotorStop(armMotor);
	while(getUSDistance(sonarSensor) > 3){
		setMotorSpeed(leftMotor, 10);
		setMotorSpeed(rightMotor, 10);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, -80, 30);
	//waitUntilMotorStop(armMotor);
	setMotorTarget(leftMotor,480, 10);
	setMotorTarget(rightMotor,480, 10);
	waitUntilMotorStop(leftMotor);

}

task stopAndResetMotors(){
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
}


void putDown() {
	startTask(stopAndResetMotors);
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, 90, 30);
	//waitUntilMotorStop(armMotor);

	setMotorTarget(leftMotor,-480, 10);
	setMotorTarget(rightMotor,-480, 10);
	waitUntilMotorStop(leftMotor);
	setMotorTarget(armMotor, -80, 30);
}


bool calibration(){
//returns true if line is on Robot's right, false if line is on left

	startTask(stopAndResetMotors);
	int encoderTarget = 90;
	displayCenteredTextLine(3, "Calibrating...");
	setLEDColor(ledOrange);

	while(true){
		setMotorSpeed(rightMotor, 5); //rotate left
		setMotorSpeed(leftMotor, -5);

		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= encoderTarget);
		startTask(stopAndResetMotors);

		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			setMotorSpeed(rightMotor, -5); //rotate right
			setMotorSpeed(leftMotor, 5);
			waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
			startTask(stopAndResetMotors);
			return false; //line is on left
		}

		setMotorSpeed(rightMotor, -5); //rotate right
		setMotorSpeed(leftMotor, 5);

		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= 2*encoderTarget); //Error <= 15 && Error >=  -15
		startTask(stopAndResetMotors);

		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			setMotorSpeed(rightMotor, 5); //rotate left
			setMotorSpeed(leftMotor, -5);
			waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
			startTask(stopAndResetMotors);
			return true; //line is on right
		}
		else {
				startTask(stopAndResetMotors);
				setMotorSpeed(rightMotor, 5); //rotate left
				setMotorSpeed(leftMotor, -5);
				waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
				startTask(stopAndResetMotors);
				encoderTarget += 90;
				if (encoderTarget >= 360){
					startTask(stopAndResetMotors);
					return true; //assume line is on left
				}
		}
	}
	return true;
}

task main(){

	pickUp();

	//if (calibration() == true){
	//	setLEDColor(ledGreen);
	//	displayCenteredTextLine(3, "The Line is on My Right");
	//	allignmentVal = 1;
	//	rightMtrSpd = 0;
	//	leftMtrSpd = 10;

	//}
	//else {
	//	setLEDColor(ledRed);
	//	displayCenteredTextLine(3, "The Line is on My Left");
	//	allignmentVal = -1;
	//	rightMtrSpd = 10;
	//	leftMtrSpd = 0;
	//}

	getColorRGB(colorSensor, red, blue, green);

	allignmentVal = -1;
	rightMtrSpd = speed;
	leftMtrSpd = 0;


	while((red / (blue+1) > 2 && red / (green+1) > 2) == false){ //while not red
		while(red < targetColor - 5 && blue < targetColor - 5){ //When Line is on right -> this is for left turns
			setMotorSpeed(rightMotor, speed*allignmentVal);				//When Line is on left -> this is for right turns
			setMotorSpeed(leftMotor, -speed*allignmentVal);
			getColorRGB(colorSensor, red, blue, green);
		}
		while(red > targetColor + 5 && blue > targetColor + 5){ //too white
			setMotorSpeed(rightMotor, rightMtrSpd);
			setMotorSpeed(leftMotor, leftMtrSpd);
			getColorRGB(colorSensor, red, blue, green);
				}
		while(red > targetColor -5 && red < targetColor + 5 && blue > targetColor - 5 && blue < targetColor + 5 ){ //on the edge
			setMotorSpeed(rightMotor, speed);
			setMotorSpeed(leftMotor, speed);
			getColorRGB(colorSensor, red, blue, green);
			}
		getColorRGB(colorSensor, red, blue, green);
	}
	putDown();

}
