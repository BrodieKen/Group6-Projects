#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Alot of help was taken from this website. refer to it to tune PID constants and implement further the ID parts
https://www.inpharmix.com/jps/PID_Controller_For_Lego_Mindstorms_Robots.html
*/


#define INTEGRAL_LIMIT  1

#define PID_DRIVE_MAX       50
#define PID_DRIVE_MIN     (-50)



float pConst = 1.5;
float iConst = 0.0;
float dConst = 0;
float targetColor = 30;
float straightDrive = 15;

int color = 0;

float Error;
float lastError = 0;
float integral = 0;
float derivative = 0;
float pidDrive = 0;

task pidController()
{


	while (true)
	{
			// Read the sensor value and scale
		color = getColorReflected(colorSensor);
		// calculate error
		Error = color - targetColor;


		//finding the integral to know how far off of desired we are
		//if the error is not within a range then dont use the integral part in correction
		if (abs(Error)< INTEGRAL_LIMIT)
		{
			integral = integral + Error; //summ all the errors past and present to know how far off one is from the desired value
		}
		else
		{
			integral = 0;
		}

		//find the derivative to know how fast its moving from the desired value
		//aswell as knowing the direction we are heading from it (away or towards)
		derivative = Error - lastError;
		lastError = Error;
		//we now know how fast we are moving from the desired value



		//determine the correction speed to apply to motors
		pidDrive = (pConst * Error) + (iConst * integral) + (dConst * derivative);


		//set some max and mins to the drive
		//un comment below when working with higher speeds, issues occur when the speed on a sharp 90 are to much that it gets lost


		//if( pidDrive > PID_DRIVE_MAX )
		//{
  //   pidDrive = PID_DRIVE_MAX;
  // 	}
  //  if( pidDrive < PID_DRIVE_MIN )
  //  {
  //   pidDrive = PID_DRIVE_MIN;
  // 	}


		//set motors speeds proportional to a straight speed
		setMotorSpeed(rightMotor, straightDrive - pidDrive);
		setMotorSpeed(leftMotor, straightDrive + pidDrive);

 	}
}




task main()
{
	startTask(pidController);
	while(1)
	{
	wait1Msec(50);
	}


}
