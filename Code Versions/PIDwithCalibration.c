#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float pConst = 1.5;
const float iConst = 0.0000005;
const float dConst = 4;
const float targetColor = 30;
const float straightDrive = 15;

float pValue;
float iValue;
float dValue;

float Error;
float lastError;
float integral = 0;
float derivative;
float pidDrive;

bool integralInitiation = false;

task stopAndResetMotors(){
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
}

bool calibration(){
//returns true if line is on Robot's right, false if line is on left

	startTask(stopAndResetMotors);
	int encoderTarget = 90;
	displayCenteredTextLine(3, "Calibrating...");
	setLEDColor(ledOrange);

	while(true){
		setMotorSpeed(rightMotor, 5); //rotate left
		setMotorSpeed(leftMotor, -5);

		waitUntil(getColorReflected(colorSensor) == colorBlack || abs(getMotorEncoder(rightMotor))>= encoderTarget);
		startTask(stopAndResetMotors);

		if (getColorReflected(colorSensor) == colorBlack){
			return false; //line is on left
		}

		setMotorSpeed(rightMotor, -5); //rotate right
		setMotorSpeed(leftMotor, 5);

		waitUntil(getColorReflected(colorSensor) == colorBlack || abs(getMotorEncoder(rightMotor))>= 2*encoderTarget);
		startTask(stopAndResetMotors);

		if (getColorReflected(colorSensor) == colorBlack){
			return true; //line is on right
		}
		else {
				startTask(stopAndResetMotors);
				setMotorSpeed(rightMotor, 5); //rotate left
				setMotorSpeed(leftMotor, -5);
				waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
				startTask(stopAndResetMotors);
				encoderTarget += 90;
				if (encoderTarget >= 360){
					startTask(stopAndResetMotors);
					return true; //assume line is on left
				}
		}
	}
	return true;
}

task main() {

	if (calibration() == true){
		setLEDColor(ledGreen);
		displayCenteredTextLine(3, "The Line is on My Right");
	}
	else {
		setLEDColor(ledRed);
		displayCenteredTextLine(3, "The Line is on My Left");
	}

	while (true){

		Error = getColorReflected(colorSensor) - targetColor;

		if (Error == 0){
			integralInitiation = true;
		}

		if (integralInitiation == true && Error < 20) {
			integral += Error;
		}

		derivative = Error - lastError;
		lastError = Error;

		pValue = pConst*Error;

		if (pValue > 25) {
			pValue = 25;
		}
		else if (pValue < -25) {
			pValue = -25;
		}

		iValue = iConst*integral;
		dValue = dConst*derivative;

		pidDrive = pValue +iValue + dValue;

		setMotorSpeed(rightMotor, straightDrive - pidDrive);
		setMotorSpeed(leftMotor, straightDrive + pidDrive);
 	}
}
