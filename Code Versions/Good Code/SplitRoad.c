#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variables


int targetColor = 30;
int pickupDistance = 360;
int armAngle = 60;
int armSpeed = 30;

int red;
int blue;
int green;

const float pConst = 0.25;
const float iConst = 0.0000005;
const float dConst = 4;

const float straightDrive = 15;
const float speed = 15;
short allignmentVal = 1; //1 for tracking right edge of line, -1 for tracking left edge of line

float pValue;
float iValue;
float dValue;

float Error;
float lastError;
float integral = 0;
float derivative;
float pidDrive;

bool integralInitiation = false;


void stopAndResetMotors(){
	//this function is used to halt motor operation and reset for many cases
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void pickUp() {

	//find box to pickup and drive into postion to begin tracking
	setMotorTarget(armMotor, armAngle, armSpeed);
	waitUntilMotorStop(armMotor);
	while(getUSDistance(sonarSensor) > 3){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, speed);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, -armAngle, armSpeed);
	//waitUntilMotorStop(armMotor);
	setMotorTarget(leftMotor,pickupDistance, speed);//480
	setMotorTarget(rightMotor,pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
}

void putDown() {
	stopAndResetMotors();
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, armAngle, armSpeed);
	//waitUntilMotorStop(armMotor);

	setMotorTarget(leftMotor,-pickupDistance, speed);
	setMotorTarget(rightMotor,-pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
	setMotorTarget(armMotor, -armAngle, armSpeed);
}

bool fork () {
	//calculate the target distance from the start point and set an encoder end condition based on that value
	//(given an error of about 50 encoder counts)

	short encoderForkDistance = 3350;

	if (abs(getMotorEncoder(leftMotor)) > encoderForkDistance){
		return true;
	}
	else{
		return false;
	}
}

void deliverySuccess(){
	int j = 0;
	for (j = 0; j<3; j++){
    displayCenteredBigTextLine(4, "Delivery Success!");
		wait1Msec(1000);
		eraseDisplay();
		wait1Msec(1000);
  }
}

task main(){
	pickUp();		//comment out for no box to pickup

//---LineTracking---//
	while (true){

		getColorRGB(colorSensor, red, blue, green);

		if (red / (blue+1) > 2 && red / (green+1) > 2) { //if red line detected
			break;
		}

		Error = (red - targetColor) + (blue - targetColor);

		if (Error <= 15 && Error >=  -15){
			integralInitiation = true;
		}

		if (integralInitiation == true && Error < 25 ) {
			integral += Error;
		}

		derivative = Error - lastError;
		lastError = Error;

		pValue = pConst*Error;

		iValue = iConst*integral;
		dValue = dConst*derivative;

		pidDrive = pValue +iValue + dValue;

		setMotorSpeed(rightMotor, straightDrive + pidDrive * allignmentVal);
		setMotorSpeed(leftMotor, straightDrive - pidDrive * allignmentVal);

		if (fork()){
			break;
		}
 	}

 	putDown();
 	deliverySuccess();
}
