#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variables
int targetColor = 30;
int pickupDistance = 360;
int armAngle = 60;
int armSpeed = 30;

// for RGB color sensor
int red;
int blue;
int green;

// Fine tune these values for the PID looop depending on course/robot
const float pConst = 0.25;
const float iConst = 0.0000005;
const float dConst = 4;

const float straightDrive = 15;
const float speed = 15;
short allignmentVal = 1; //1 for tracking right edge of line, -1 for tracking left edge of line

float pValue;
float iValue;
float dValue;

float Error;
float lastError;
float integral = 0;
float derivative;
float pidDrive;

bool integralInitiation = false;


void stopAndResetMotors(){
	//this function is used to halt motor operation and reset encoders for many cases
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void pickUp() {

	//find box to pickup and drive into postion to begin tracking
	
	setMotorTarget(armMotor, armAngle, armSpeed);	//raise arm
	waitUntilMotorStop(armMotor);
	
	while(getUSDistance(sonarSensor) > 3){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, speed);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, -armAngle, armSpeed);	//lower arm
	
	setMotorTarget(leftMotor,pickupDistance, speed);
	setMotorTarget(rightMotor,pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
}

void putDown() {
	//release the box down when the robot has reached its destination
	stopAndResetMotors();
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, armAngle, armSpeed);	//raise arm

	setMotorTarget(leftMotor,-pickupDistance, speed);
	setMotorTarget(rightMotor,-pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
	
	setMotorTarget(armMotor, -armAngle, armSpeed);	//lower arm
}

bool fork () {
	//set target encoder distance for cargo delivery
	short encoderForkDistance = 3350;

	if (abs(getMotorEncoder(leftMotor)) > encoderForkDistance){
		return true;
	}
	else{
		return false;
	}
}

void deliverySuccess(){
	//Flash completion message on screen upon successful cargo delivery 
	int j = 0;
	for (j = 0; j<3; j++){
		displayCenteredBigTextLine(4, "Delivery Success!");
		wait1Msec(1000);
		eraseDisplay();
		wait1Msec(1000);
	}
}

task main(){
	pickUp();		//comment out for no cargo

//---LineTracking---//
	while (true){
	//Standard PID loop algorithm. compares current value of color sensor to the desired value of color sensor and adjusts motor speeds proportionally

		getColorRGB(colorSensor, red, blue, green);

		if (red / (blue+1) > 2 && red / (green+1) > 2) { //if red line detected exit PID loop to end code
			break;
		}
		
		//calculate error by comparing color sensor to the desired value of color sensor
		Error = (red - targetColor) + (blue - targetColor);

		//intiate integral counting once the line has been found to track (baseline)
		if (Error <= 15 && Error >=  -15){
			integralInitiation = true;
		}
		if (integralInitiation == true && Error < 25 ) {
			integral += Error;	//intregral is sum of past errors
		}

		//predict where robot is heading based on rate of change between current and previous error
		derivative = Error - lastError;
		lastError = Error;

		//convert color sensor values to speed values using optimized constants
		pValue = pConst*Error;
		iValue = iConst*integral;
		dValue = dConst*derivative;

		//set PID drive adjustment
		pidDrive = pValue +iValue + dValue;

		//set motor speeds
		setMotorSpeed(rightMotor, straightDrive + pidDrive * allignmentVal);
		setMotorSpeed(leftMotor, straightDrive - pidDrive * allignmentVal);

		if (fork()){
			break;
		}
 	}

 	putDown();	//comment out for no cargo
 	deliverySuccess();
}
