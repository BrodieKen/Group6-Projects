#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Variables
const float targetColor = 30;
int pickupDistance = 360;
int armAngle = 60;
int armSpeed = 30;


// for RGB color sensor
int red;
int blue;
int green;

// Fine tune these values for the PID looop depending on course/robot
const float pConst = 0.5;
const float iConst = 0.00005; 
const float dConst = 4;

const float straightDrive = 15;
const float speed = 15;
short allignmentVal = 1; //1 for tracking right edge of line, -1 for tracking left edge of line

float pValue;
float iValue;
float dValue;

float Error;
float lastError;
float integral = 0;
float derivative;
float pidDrive;

bool integralInitiation = false;

void stopAndResetMotors(){
	//this function is used to halt motor operation and reset for many cases
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
}

void pickUp() {
	//find box to pickup and drive into postion to begin tracking
	
	setMotorTarget(armMotor, armAngle, armSpeed);
	waitUntilMotorStop(armMotor);
	
	while(getUSDistance(sonarSensor) > 3){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, speed);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, -armAngle, armSpeed);

	setMotorTarget(leftMotor,pickupDistance, speed);
	setMotorTarget(rightMotor,pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
}

void putDown() {
	//release the box down when the robot has reached its destination
	stopAndResetMotors();
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, armAngle, armSpeed);

	setMotorTarget(leftMotor,-pickupDistance, speed);
	setMotorTarget(rightMotor,-pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
	
	setMotorTarget(armMotor, -armAngle, armSpeed);
}

bool calibration(){
//Return true if Robot is tracking left edge of line
//Return false if robot is tracking right edge of line
	
	int encoderTarget = 90;		//90 encoder counts = 45 degrees
	int calibrationSpeed = 5;

	stopAndResetMotors();

	displayCenteredTextLine(3, "Calibrating...");
	setLEDColor(ledOrange);

	while(true){
		setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
		setMotorSpeed(leftMotor, -calibrationSpeed);

		//rotate until either the color is found or rotation limit reached
		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= encoderTarget);
		stopAndResetMotors();

		//if the target color has been found, rotate back to initial position and finish calibration
		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			setMotorSpeed(rightMotor, -calibrationSpeed); //rotate right
			setMotorSpeed(leftMotor, calibrationSpeed);
			waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget/2);
			stopAndResetMotors();
			return false; //Robot is tracking right edge of line
		}

		setMotorSpeed(rightMotor, -calibrationSpeed); //rotate right
		setMotorSpeed(leftMotor, calibrationSpeed);

		//rotate back the opposite direction until color is found or rotation limit reached
		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= 2*encoderTarget); //Error <= 15 && Error >=  -15
		stopAndResetMotors();

		//if the target color has been found, rotate back to initial position and finish calibration
		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
			setMotorSpeed(leftMotor, -calibrationSpeed);
			waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget/2);
			stopAndResetMotors();
			return true; //Robot is tracking left edge of line
		}
		else {
			//if no color was found on first sweep, reset to centre and widen sweep range by 45 degrees
			stopAndResetMotors();
			setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
			setMotorSpeed(leftMotor, -calibrationSpeed);
			waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget/2);
			stopAndResetMotors();
			encoderTarget += 90;

			// if no line is found through 360 degrees, assume left edge is being tracked
			if (encoderTarget >= 360){
				stopAndResetMotors();
				return true;
			}
		}
	}
	
	return true;
}

task main() {

	pickUp();	//comment out for no cargo

	//set motor control variables according to calibration
	if (calibration() == true){ 	
		allignmentVal = -1;
	}
	else {		
		allignmentVal = 1;
	}
	stopAndResetMotors();

//---LineTracking---//
	while (true){
	//Standard PID loop algorithm. compares current value of color sensor to the desired value of color sensor and adjusts motor speeds proportionally

		getColorRGB(colorSensor, red, blue, green);

		if (red / (blue+1) > 2 && red / (green+1) > 2) { //if red line detected exit PID loop to end code
			break;
		}
		
		//calculate error by comparing color sensor to the desired value of color sensor
		Error = (red - targetColor) + (blue - targetColor);

		//intiate integral counting once the line has been found to track (baseline)
		if (Error <= 15 && Error >=  -15){
			integralInitiation = true;
		}
		if (integralInitiation == true && Error < 25 ) {
			integral += Error;	//intregral is sum of past errors
		}

		//predict where robot is heading based on rate of change between current and previous error
		derivative = Error - lastError;
		lastError = Error;

		//convert color sensor values to speed values using optimized constants
		pValue = pConst*Error;
		iValue = iConst*integral;
		dValue = dConst*derivative;

		//set PID drive adjustment
		pidDrive = pValue +iValue + dValue;

		//set motor speeds
		setMotorSpeed(rightMotor, straightDrive + pidDrive * allignmentVal);
		setMotorSpeed(leftMotor, straightDrive - pidDrive * allignmentVal);
 	}
	
 	putDown();	//comment out for no cargo
}
