#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float pConst = 0.25;
const float iConst = 0; //0.0000005;
const float dConst = 0; //4;
const float targetColor = 30;
const float straightDrive = 15;
const float speed = 15;
short allignmentVal = 1; //1 for tracking right edge of line, -1 for tracking left edge of line

float pValue;
float iValue;
float dValue;

float Error;
float lastError;
float integral = 0;
float derivative;
float pidDrive;

int red;
int blue;
int green;

int pickupDistance = 480;
int armAngle = 55;
int armSpeed = 30;

bool integralInitiation = false;

void stopAndResetMotors(){
	//this function is used to halt motor operation and reset for many cases
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void pickUp() {

	//find box to pickup and drive into postion to begin tracking
	setMotorTarget(armMotor, armAngle, armSpeed);
	waitUntilMotorStop(armMotor);
	while(getUSDistance(sonarSensor) > 3){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, speed);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, -armAngle, armSpeed);
	//waitUntilMotorStop(armMotor);
	setMotorTarget(leftMotor,pickupDistance, speed);//480
	setMotorTarget(rightMotor,pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
}

void putDown() {
	stopAndResetMotors();
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	setMotorTarget(armMotor, armAngle, armSpeed);
	//waitUntilMotorStop(armMotor);

	setMotorTarget(leftMotor,-pickupDistance, speed);
	setMotorTarget(rightMotor,-pickupDistance, speed);
	waitUntilMotorStop(leftMotor);
	setMotorTarget(armMotor, -armAngle, armSpeed);
}

bool calibration(){
//returns true if line is on Robot's right, false if line is on left
	int encoderTarget = 90;
	int calibrationSpeed = 5;

	stopAndResetMotors();

	displayCenteredTextLine(3, "Calibrating...");
	setLEDColor(ledOrange);

	while(true){
		setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
		setMotorSpeed(leftMotor, -calibrationSpeed);

		//rotate until either the color is found or limit reached
		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= encoderTarget);
		stopAndResetMotors();

		//if the target color has been found, rotate back straight and finish calibration
		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			//setMotorSpeed(rightMotor, -calibrationSpeed); //rotate right
			//setMotorSpeed(leftMotor, calibrationSpeed);
			//waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
			stopAndResetMotors();
			return false; //line is on left
		}

		setMotorSpeed(rightMotor, -calibrationSpeed); //rotate right
		setMotorSpeed(leftMotor, calibrationSpeed);

		//rotate back the opposite direction until color is found or limit reached
		waitUntil((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)  || abs(getMotorEncoder(rightMotor))>= 2*encoderTarget); //Error <= 15 && Error >=  -15
		stopAndResetMotors();

		//if the target color has been found, rotate back straight and finish calibration
		if ((getColorReflected(colorSensor) <= targetColor + 10 && getColorReflected(colorSensor) >= targetColor - 10)){
			//setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
			//setMotorSpeed(leftMotor, -calibrationSpeed);
			//waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
			stopAndResetMotors();
			return true; //line is on right
		}
		else {
			//if no color was found on first sweep, reset to centre and widen range
				stopAndResetMotors();
				setMotorSpeed(rightMotor, calibrationSpeed); //rotate left
				setMotorSpeed(leftMotor, -calibrationSpeed);
				waitUntil(abs(getMotorEncoder(rightMotor))>= encoderTarget);
				stopAndResetMotors();
				encoderTarget += 90;

				if (encoderTarget >= 360){
					stopAndResetMotors();
					return true; //assume line is on left
				}
		}
	}
	return true;
}

task main() {

	pickUp();

	if (calibration() == true){ //calibrate says line is on right, set motor control variables accordingly
		setLEDColor(ledGreen);
		displayCenteredTextLine(3, "The Line is on My Right");
		allignmentVal = -1;
	}
	else {											//calibrate says line is on left, set motor control variables accordingly
		setLEDColor(ledRed);
		displayCenteredTextLine(3, "The Line is on My Left");
		allignmentVal = 1;
	}
	stopAndResetMotors();

	while (true){

		getColorRGB(colorSensor, red, blue, green);

		if (red / (blue+1) > 4 && red / (green+1) > 4) { //if red line detected
			break;
		}

		Error = (red - targetColor) + (blue - targetColor);

		if (Error == 0){
			integralInitiation = true;
		}

		if (integralInitiation == true && Error < 20) {
			integral += Error;
		}

		derivative = Error - lastError;
		lastError = Error;

		pValue = pConst*Error;

		//if (pValue > 25) {
		//	pValue = 25;
		//}
		//else if (pValue < -25) {
		//	pValue = -25;
		//}

		iValue = iConst*integral;
		dValue = dConst*derivative;

		pidDrive = pValue +iValue + dValue;

		setMotorSpeed(rightMotor, straightDrive + pidDrive * allignmentVal);
		setMotorSpeed(leftMotor, straightDrive - pidDrive * allignmentVal);
 	}

 	putDown();
}
